
#*
#* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
#* SPDX-License-Identifier: MIT-0
#*
#* Permission is hereby granted, free of charge, to any person obtaining a copy of this
#* software and associated documentation files (the "Software"), to deal in the Software
#* without restriction, including without limitation the rights to use, copy, modify,
#* merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
#* permit persons to whom the Software is furnished to do so.
#*
#* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
#* INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
#* PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
#* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
#* OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
#* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#*

#------------------------------------------------------------------------------
#
# Template: opsmgmt-target-account-patching.yml
# Purpose:  Configures the target accounts for multi-account/multi-region patching.
#
#
#------------------------------------------------------------------------------

AWSTemplateFormatVersion: 2010-09-09
Description: AWS CloudFormation template to configure a target account for a scheduled multi-account and multi-region patching.

#-----------------------------------------------------------
# Parameters
#-----------------------------------------------------------
Parameters:
  ExecutionLogsS3Bucket:
    Type : 'String'
    Description: 'Name of the S3 bucket that lives in the central account.'
    Default: ''
  InventoryExecutionLogsS3BucketPrefix:
    Type : 'String'
    Description: 'Name of the prefix to use in the central account S3 bucket for inventory execution data.'
    Default: 'inventory-execution-logs'
  PatchingExecutionLogsS3BucketPrefix:
    Type : 'String'
    Description: 'Name of the prefix to use in the central account S3 bucket for inventory execution data. NOTE: This is only used if the GatherInventory parameter is set to true'
    Default: 'patching-execution-logs'    
  PatchingOperation:
    Type: String
    AllowedValues:
      - Scan
      - Install
    Default: Install
    Description: (Required) The update or configuration to perform on the instance. The system checks if patches specified in the patch baseline are installed on the instance. The install operation installs patches missing from the baseline.
  PatchingRebootOption:
    Type: String
    AllowedValues:
      - RebootIfNeeded
      - NoReboot
    Default: RebootIfNeeded
    Description: 'Reboot behavior after a patch Install operation. If you choose NoReboot and patches are installed, the instance is marked as non-compliant until a subsequent reboot and scan.'
  PatchingInstallOverrideList:
    Type: String
    Default: ''
    Description: (Optional) List of patches to override.
  InstanceOnlineTimeoutSeconds:
    Type: Number
    Default: 5400
    Description: (Optional) The time to wait for an instance to check in with Systems Manager (come online) before timing out. Default is 90 minutes. 
  PatchingAttempts:
    Type: Number
    Default: 1
    Description: The number of times to attempt to run AWS-RunPatchBaseline on an instance before giving up for the current patching cycle.
  PatchingTimeoutSeconds:
    Type: Number
    Default: 7200
    Description: (Optional) The maximum duration in seconds of the patching operation before timing out. Default is 2 hours.
  PatchSchedule:
    Type: String
    Default: cron(59 23 ? * SAT *)
    Description: The cron schedule expression used for patching. TIMES ARE IN UTC. Default is every Saturday at 11:59 PM UTC. https://docs.aws.amazon.com/systems-manager/latest/userguide/reference-cron-and-rate-expressions.html
  GatherInventory:
    Type: String
    Default: 'false'
    AllowedValues:
      - 'true'
      - 'false'
    Description: Perform a software inventory of the instance after patching. Default is false.              
  StartInstances:
    Type: String
    AllowedValues:
      - 'true'
      - 'false'
    Default: 'false'
    Description: 'If true, the instance will be started prior to patching if it is stopped. If the instance was stopped prior to patching, it will be stopped again after patching is complete. Default is false.'
  AutoAttachInstanceProfile:
    Type: String
    AllowedValues:
      - 'Enabled'
      - 'Disabled'
    Description: When enabled, the patching automation will temporarily attach an instance profile or IAM policies to the existing instance profile role that are needed by Systems Manager to execute commands. It is recommended/preferred that you use SSM QuickSetup or self-manage instance profiles.   
    Default: Enabled
  DeployDefaultPatchBaselines:
    Type: String
    AllowedValues:
      - 'Enabled'
      - 'Disabled'
    Description: When enabled, the patching automation will temporarily attach an instance profile or IAM policies to the existing instance profile role that are needed by Systems Manager to execute commands. It is recommended/preferred that you use SSM QuickSetup or self-manage instance profiles.   
    Default: Enabled

Metadata: 
  AWS::CloudFormation::Interface: 
    ParameterGroups: 
      - 
        Label: 
          default: "Central Logging and Inventory"
        Parameters: 
          - ExecutionLogsS3Bucket
          - PatchingExecutionLogsS3BucketPrefix
          - InventoryExecutionLogsS3BucketPrefix
      - 
        Label: 
          default: "Patching Settings"
        Parameters: 
          - PatchingOperation
          - PatchingRebootOption
          - PatchSchedule
          - PatchingInstallOverrideList
          - StartInstances
          - GatherInventory
          - AutoAttachInstanceProfile
          - PatchingTimeoutSeconds
          - PatchingRetries
          - InstanceOnlineTimeoutSeconds
      - 
        Label: 
          default: "Default Patch Baselines"
        Parameters: 
          - DeployDefaultPatchBaselines          


Conditions:
  AutoAttachInstanceProfile: !Equals [!Ref AutoAttachInstanceProfile, 'Enabled']
  DeployDefaultPatchBaselines: !Equals [!Ref DeployDefaultPatchBaselines, 'Enabled']


Resources:
  #-------------------------------------------------
  # Patch Baselines for each operating system. These are optionally deployed and used as the defaults for the account/region. They can be customized
  #-------------------------------------------------
  UbuntuPatchBaseline:
    Condition:  DeployDefaultPatchBaselines
    Type: 'AWS::SSM::PatchBaseline'
    Properties:
      ApprovalRules:
        PatchRules:
          - PatchFilterGroup:
              PatchFilters:
                - Values:
                    - '*'
                  Key: SECTION
            ApproveAfterDays: 0
      Name: DefaultUbuntuPatchBaseline
      OperatingSystem: UBUNTU

  AmazonLinux2PatchBaseline:
    Type: 'AWS::SSM::PatchBaseline'
    Properties:
      ApprovedPatchesEnableNonSecurity: true
      Name: DefaultAmazonLinux2PatchBaseline
      ApprovalRules:
        PatchRules:
          - EnableNonSecurity: false
            ApproveAfterDays: 0
            PatchFilterGroup:
              PatchFilters:
                - Values:
                    - Security
                  Key: CLASSIFICATION
      OperatingSystem: AMAZON_LINUX_2
      ApprovedPatches:
        - kernel*  

  OraclePatchBaseline:
    Condition:  DeployDefaultPatchBaselines  
    Type: 'AWS::SSM::PatchBaseline'
    Properties:
      ApprovedPatchesEnableNonSecurity: true
      Name: DefaultOraclePatchBaseline
      ApprovalRules:
        PatchRules:
          - EnableNonSecurity: false
            ApproveAfterDays: 0
            PatchFilterGroup:
              PatchFilters:
                - Values:
                    - Security
                  Key: CLASSIFICATION
      OperatingSystem: ORACLE_LINUX
      ApprovedPatches:
        - kernel*
  
  CentosPatchBaseline:
    Condition:  DeployDefaultPatchBaselines  
    Type: 'AWS::SSM::PatchBaseline'
    Properties:
      ApprovalRules:
        PatchRules:
          - EnableNonSecurity: true
            ApproveAfterDays: 0
            PatchFilterGroup:
              PatchFilters:
                - Values:
                    - '*'
                  Key: CLASSIFICATION
      Name: DefaultCentosPatchBaseline
      OperatingSystem: CENTOS
      
  DebianPatchBaseline:
    Condition:  DeployDefaultPatchBaselines  
    Type: 'AWS::SSM::PatchBaseline'
    Properties:
      ApprovalRules:
        PatchRules:
          - PatchFilterGroup:
              PatchFilters:
                - Values:
                    - '*'
                  Key: SECTION
            ApproveAfterDays: 0
      Name: DefaultDebianPatchBaseline
      OperatingSystem: DEBIAN

  RedhatPatchBaseline:
    Condition:  DeployDefaultPatchBaselines
    Type: 'AWS::SSM::PatchBaseline'
    Properties:
      ApprovedPatchesEnableNonSecurity: true
      Name: DefaultRedhatPatchBaseline
      ApprovalRules:
        PatchRules:
          - EnableNonSecurity: false
            ApproveAfterDays: 0
            PatchFilterGroup:
              PatchFilters:
                - Values:
                    - Security
                  Key: CLASSIFICATION
      OperatingSystem: REDHAT_ENTERPRISE_LINUX
      ApprovedPatches:
        - kernel*



  SusePatchBaseline:
    Condition:  DeployDefaultPatchBaselines
    Type: 'AWS::SSM::PatchBaseline'
    Properties:
      ApprovalRules:
        PatchRules:
          - PatchFilterGroup:
              PatchFilters:
                - Values:
                    - Security
                  Key: CLASSIFICATION
            ApproveAfterDays: 0
      Name: DefaultSusePatchBaseline
      ApprovedPatches:
        - kernel*
      OperatingSystem: SUSE

  AmazonLinuxPatchBaseline:
    Condition:  DeployDefaultPatchBaselines
    Type: 'AWS::SSM::PatchBaseline'
    Properties:
      ApprovedPatchesEnableNonSecurity: true
      Name: DefaultAmazonLinuxPatchBaseline
      ApprovalRules:
        PatchRules:
          - EnableNonSecurity: false
            ApproveAfterDays: 0
            PatchFilterGroup:
              PatchFilters:
                - Values:
                    - Security
                  Key: CLASSIFICATION
      OperatingSystem: AMAZON_LINUX
      ApprovedPatches:
        - kernel*

  WindowsPatchBaseline:
    Condition:  DeployDefaultPatchBaselines
    Type: 'AWS::SSM::PatchBaseline'
    Properties:
      ApprovalRules:
        PatchRules:
          - PatchFilterGroup:
              PatchFilters:
                - Values:
                    - SecurityUpdates
                    - CriticalUpdates
                  Key: CLASSIFICATION
            ApproveAfterDays: 0
      Name: DefaultWindowsPatchBaseline
      OperatingSystem: WINDOWS

  #-------------------------------------------------
  # Set Default Patch Baselines for the account using a custom resource that will also update and unset them during stack updates and deletion.
  #-------------------------------------------------
  DefaultAmazonLinux2PatchBaseline:
    Condition:  DeployDefaultPatchBaselines
    Type: Custom::DefaultPatchBaseline
    Properties:
      ServiceToken: !GetAtt LambdaDefaultPatchBaselineCustomResource.Arn
      BaselineId: !Ref AmazonLinux2PatchBaseline
  DefaultOraclePatchBaseline:
    Condition:  DeployDefaultPatchBaselines
    Type: Custom::DefaultPatchBaseline
    Properties:
      ServiceToken: !GetAtt LambdaDefaultPatchBaselineCustomResource.Arn
      BaselineId: !Ref OraclePatchBaseline
        
  DefaultCentosPatchBaseline:
    Condition:  DeployDefaultPatchBaselines
    Type: Custom::DefaultPatchBaseline
    Properties:
      ServiceToken: !GetAtt LambdaDefaultPatchBaselineCustomResource.Arn
      BaselineId: !Ref CentosPatchBaseline    

  DefaultUbuntuPatchBaseline:
    Condition:  DeployDefaultPatchBaselines
    Type: Custom::DefaultPatchBaseline
    Properties:
      ServiceToken: !GetAtt LambdaDefaultPatchBaselineCustomResource.Arn
      BaselineId: !Ref UbuntuPatchBaseline    

  DefaultDebianPatchBaseline:
    Condition:  DeployDefaultPatchBaselines
    Type: Custom::DefaultPatchBaseline
    Properties:
      ServiceToken: !GetAtt LambdaDefaultPatchBaselineCustomResource.Arn
      BaselineId: !Ref DebianPatchBaseline

  DefaultSusePatchBaseline:
    Condition:  DeployDefaultPatchBaselines
    Type: Custom::DefaultPatchBaseline
    Properties:
      ServiceToken: !GetAtt LambdaDefaultPatchBaselineCustomResource.Arn
      BaselineId: !Ref SusePatchBaseline

  DefaultRedhatPatchBaseline:
    Condition:  DeployDefaultPatchBaselines
    Type: Custom::DefaultPatchBaseline
    Properties:
      ServiceToken: !GetAtt LambdaDefaultPatchBaselineCustomResource.Arn
      BaselineId: !Ref RedhatPatchBaseline      
  DefaultAmazonLinuxPatchBaseline:
    Condition:  DeployDefaultPatchBaselines
    Type: Custom::DefaultPatchBaseline
    Properties:
      ServiceToken: !GetAtt LambdaDefaultPatchBaselineCustomResource.Arn
      BaselineId: !Ref AmazonLinuxPatchBaseline

  DefaultWindowsPatchBaseline:
    Condition:  DeployDefaultPatchBaselines
    Type: Custom::DefaultPatchBaseline
    Properties:
      ServiceToken: !GetAtt LambdaDefaultPatchBaselineCustomResource.Arn
      BaselineId: !Ref WindowsPatchBaseline    

        
  

  #-------------------------------------------------
  # Custom resource Lambda used to set the default patch baselines for the account/region. 
  #-------------------------------------------------
  LambdaDefaultPatchBaselineCustomResource:
    Type: AWS::Lambda::Function
    Properties:
      Description: Cloudformation Custom Resource function used to register default patch baselines
      Handler: index.handler
      Role: !GetAtt LambdaDefaultPatchbaselineCustomResourceExecutionRole.Arn
      Code:
        ZipFile: |
          import logging
          import boto3
          import urllib3
          import uuid
          from botocore.exceptions import ClientError
          import cfnresponse

          logger = logging.getLogger(__name__)
          logger.setLevel(logging.DEBUG)

          try:
              ssm_client = boto3.client("ssm")
              pass
          except Exception as e:
              logger.error('Unable to create SSM client: {}'.format(str(e)))

          def create(baseline_id):
              logger.info("Got Create")   
              default_baseline_id = ssm_client.register_default_patch_baseline(BaselineId=baseline_id)
              logger.info("BaselineId: {}".format(default_baseline_id['BaselineId']))
              return cfnresponse.SUCCESS, {"BaselineId": default_baseline_id['BaselineId']}, uuid.uuid4().hex
          def update(baseline_id):
              logger.info("Got Update")
              default_baseline_id = ssm_client.register_default_patch_baseline(BaselineId=baseline_id)
              return cfnresponse.SUCCESS, {"BaselineId": default_baseline_id['BaselineId']}
          def delete(baseline_id):
              logger.info("Got Delete")
              try:
                  baseline = get_patch_baseline(baseline_id)
                  if baseline.get('DefaultBaseline', False):
                      default_baseline = [item for item in ssm_client.describe_patch_baselines()['BaselineIdentities'] if item['BaselineId'].lower().startswith('arn:') and item.get('OperatingSystem', '') == baseline.get('OperatingSystem', '')]
                      default_baseline = default_baseline[0] if len(default_baseline) else {}
                      logger.info('AWS Default Baseline: {}'.format(default_baseline))
                      baseline_id = ssm_client.register_default_patch_baseline(BaselineId=default_baseline.get('BaselineId', ''))
                      logger.info ('Set default baseline to: {}'.format(baseline_id))
                  else:
                      logger.info ('Not default baseline for OS, skipping')
                  return cfnresponse.SUCCESS, {}
              except ClientError as e:
                  if e.response['Error']['Code'] == "DoesNotExistException":
                      logger.warn('Got DoesNotExistException: {}'.format(str(e)))
                      return cfnresponse.SUCCESS, {}
                  else:
                      raise ValueError("Cannot deregister " + baseline_id + ": " + str(e))
          def get_patch_baseline(baseline_id):
              baseline = [item for item in ssm_client.describe_patch_baselines()['BaselineIdentities'] if item['BaselineId'] == baseline_id]
              return baseline[0] if len(baseline) else {}
                      
          def handler(event, context):
              logger.debug(event)
              if ssm_client == None:
                  cfnresponse.send(event, context, cfnresponse.FAILED, {'Reason': 'Unable to create SSM Client.'})
              try:
                  baseline_id = event.get('ResourceProperties').get('BaselineId')
                  logger.debug("BaselineId: {}".format(baseline_id))   
                  physical_id = event.get('PhysicalResourceId', '')
                  if event['RequestType'] == 'Create':
                      response, data, physical_id = create(baseline_id)
                  elif event['RequestType'] == 'Update':
                      old_baseline_id = event.get('OldResourceProperties').get('BaselineId')
                      if  old_baseline_id != baseline_id:
                          response, data, _ = create(baseline_id)
                          if get_patch_baseline(old_baseline_id).get('OperatingSystem', '') != get_patch_baseline(baseline_id).get('OperatingSystem', ''):
                              delete(old_baseline_id)
                      else: response, data  = update(old_baseline_id)
                  elif event['RequestType'] == 'Delete':
                      response, data = delete(baseline_id)
                  else:
                      logger.error('Unknown operation: {}'.format(event['RequestType']))
                      raise ValueError ('Unknown Operation.')
                  cfnresponse.send(event, context, response, data, physical_id)
              except Exception as e:
                  logger.error('Exception: {}'.format(str(e)))
                  cfnresponse.send(event, context, cfnresponse.FAILED, {'Reason': str(e)}, physical_id)
                  raise
      Runtime: python3.8
      Timeout: 120        

  #-------------------------------------------------
  # IAM Role used by Lambda custom resource
  #-------------------------------------------------
  LambdaDefaultPatchbaselineCustomResourceExecutionRole:  
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action:
              - 'sts:AssumeRole'
      Path: /
      Policies:
        - PolicyName: ExecutionPolicy
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - ssm:DescribePatchBaselines
                  - ssm:RegisterDefaultPatchBaseline
                Resource: '*'
              - Effect: Allow
                Action: 
                - 'logs:CreateLogGroup'
                - 'logs:CreateLogStream'
                - 'logs:PutLogEvents'
                Resource: 'arn:aws:logs:*:*:*'

  #-------------------------------------------------
  # Patching Automation document that orchestrates temporarily running instances stopped instances for patching as well as other scenarios. 
  #-------------------------------------------------
  PatchingAutomation:
    Type: AWS::SSM::Document
    Properties:
      DocumentType: Automation
      Content: 
        description: ''
        assumeRole: "{{AutomationAssumeRole}}"
        schemaVersion: '0.3'
        parameters:
          AutomationAssumeRole:
            type: String
            default: ''        
          InstanceId:
            type: String
          PatchingOperation:
            type: String
            allowedValues:
              - Scan
              - Install
            default: Scan
            description: (Required) The update or configuration to perform on the instance. The system checks if patches specified in the patch baseline are installed on the instance. The install operation installs patches missing from the baseline.
          PatchingRebootOption:
            type: String
            allowedValues:
              - RebootIfNeeded
              - NoReboot
            default: NoReboot
            description: '(Optional) Reboot behavior after a patch Install operation. If you choose NoReboot and patches are installed, the instance is marked as non-compliant until a subsequent reboot and scan.'
          PatchingInstallOverrideList:
            type: String
            default: ''
          PatchingOutputS3BucketName:
            type: String
            default: ''
            description: (Optional) The name of the S3 bucket to send patching execution logs to.
          PatchingOutputS3KeyPrefix:
            type: String
            default: ''
            description: (Optional) The path in the S3 bucket to send patching execution logs to.
          InventoryOutputS3BucketName:
            type: String
            default: ''
            description: (Optional) The name of the S3 bucket to send inventory execution logs to.
          InventoryOutputS3KeyPrefix:
            type: String
            default: ''
            description: (Optional) The path in the S3 bucket to send inventory execution logs to.             
          PatchingTimeoutSeconds:
            type: Integer
            default: 7200
            description: (Optional) The maximum duration in seconds of the patching operation before timing out. Default is 2 hours.    
          GatherInventory:
            type: String
            default: 'false'
            allowedValues:
              - 'true'
              - 'false'
            description: (Optional) Gather a software inventory of the system after patching. Default is false.
          AttachInstanceProfileArn:
            type: String
            default: ''
            description: (Optional) The Arn of an instance profile that will be temporarily attached to instances that do not have an IAM Role/Profile attached. This can be used to ensure SSM can run patching commands on instances without an IAM profile. If empty, the automation will not attempt to attach a profile to unmanaged instances.
          AttachPolicyArns:
            type: StringList
            default: []
            description: (Optional) A list of Arns to temporarily attach to the instance proile of an instance. This can be used to temporarily enable SSM to run commands in situations where permanently attaching policies is not desired. If empty, no policies are attached.
          StartInstance:
            type: String
            allowedValues:
              - 'true'
              - 'false'
            default: 'false'
            description: '(Optional) If true, the instance will be started prior to patching if it is stopped. If the instance was stopped prior to patching, it will be stopped again after patching is complete. Default is false.'
          SkipTags:
            type: MapList
            description: 'A MapList of instances Tags and (optional) Values that, if present on the instance, indicate it should not be patched and the automation should stop. By default, if tags NoPatching or SkipPatching are set the automation will be stopped.'
            default:
              - Key: SkipPatching
                Values:
                  - 'Yes'
                  - 'True'
                  - 'true'
              - Key: NoPatching
                Values:
                  - 'Yes'
                  - 'True'
                  - 'true'
              - Key: NoPatching
              - Key: SkipPatching
        mainSteps:
          - name: DescribeTags
            action: 'aws:executeAwsApi'
            inputs:
              Service: ec2
              Api: DescribeTags
              Filters:
                - Name: resource-id
                  Values:
                    - '{{InstanceId}}'
              MaxResults: 1000
            outputs:
              - Selector: $.Tags
                Name: Tags
                Type: MapList       
          - name: CheckForSkippedTags
            action: 'aws:executeScript'
            inputs:
              Runtime: python3.7
              Handler: script_handler
              Script: |-
                def script_handler(events, context):
                    print(events['InstanceTags'])
                    print(events['SkipTags'])
                    for skip_tag in events['SkipTags']:
                        if skip_tag.get('Key', None):
                            for matching_tag in [tag for tag in events['InstanceTags'] if tag.get('Key','') == skip_tag['Key']]:
                                if not skip_tag.get('Values', []):
                                    print("Matching tag key: {}, any value".format(matching_tag['Key']))
                                    return {'Match': True}
                                if [value for value in skip_tag['Values'] if value == matching_tag['Value']]:
                                    print("Matching tag key: {}, value: {}".format(matching_tag['Key'], matching_tag['Value']))
                                    return {'Match': True}
                    return {'Match': False}
              InputPayload:
                InstanceTags: '{{DescribeTags.Tags}}'
                SkipTags: '{{SkipTags}}'
            outputs:
              - Name: Match
                Selector: $.Payload.Match
                Type: Boolean
            description: Checks if there are tags returned by DescribeTags that match SkipTags
          - name: choiceSkip
            action: 'aws:branch'
            inputs:
              Choices:
                - Variable: '{{CheckForSkippedTags.Match}}'
                  BooleanEquals: false
                  NextStep: CheckExistingExecution
            description: 'If there was a matching SkipTag on the instance, stops the automation.'
            isEnd: true
          - name: CheckExistingExecution
            action: 'aws:executeScript'
            inputs:
              Runtime: python3.7
              Handler: script_handler
              Script: |-
                import boto3
                ssm = boto3.client('ssm')
                def script_handler(events, context):
                    print(events['InstanceTags'])
                    for matching_tag in [tag for tag in events['InstanceTags'] if tag.get('Key','') == 'InstancePatchingLastExecutionId']:
                        last_execution_id = matching_tag['Value']
                        running_execution = ssm.describe_automation_executions(
                            Filters=[
                                {
                                    'Key': 'ExecutionId',
                                    'Values': [last_execution_id]
                                },
                                {
                                    'Key': 'ExecutionStatus',
                                    'Values': ['InProgress']
                                }                              
                            ]
                            )
                        if len(running_execution.get('AutomationExecutionMetadataList', [])):
                            print("Last Execution {} currently in progress".format(last_execution_id))
                            return {'InProgress': True}
                    return {'InProgress': False}
              InputPayload:
                InstanceTags: '{{DescribeTags.Tags}}'
            outputs:
              - Name: InProgress
                Selector: $.Payload.InProgress
                Type: Boolean              
            description: Check if another execution of the patching automation is currently being applied to the instance.  
          - name: choicePatchingAutomationAlreadyRunning
            action: 'aws:branch'
            inputs:
              Choices:
                - Variable: '{{CheckExistingExecution.InProgress}}'
                  BooleanEquals: false
                  NextStep: TagInstancePatchingLastExecutionId    
            description: 'If there is already another execution running, do not proceed.'
            isEnd: true            
          - name: TagInstancePatchingLastExecutionId
            action: 'aws:createTags'
            inputs:
              ResourceType: EC2
              ResourceIds:
                - '{{InstanceId}}'
              Tags:
                - Key: InstancePatchingLastExecutionId
                  Value: '{{automation:EXECUTION_ID}}'
            description: Creates the tag InstancePatchingLastExecutionId. This is used to store the current Execution Id. Logic in the automation ensures only one instantiation runs on an instance at a time.            
          - name: GetInstanceState
            action: 'aws:executeAwsApi'
            outputs:
              - Name: State
                Selector: '$.Reservations[0].Instances[0].State.Name'
                Type: String
            inputs:
              Service: ec2
              Api: DescribeInstances
              InstanceIds:
                - '{{InstanceId}}'
            description: Gets the current state of the instance (i.e. running or stopped).
          - name: GetDatetime
            action: 'aws:executeScript'
            inputs:
              Runtime: python3.6
              Handler: script_handler
              Script: |-
                import datetime
                def script_handler(events, context):
                  return {'datetime': str(datetime.datetime.now())}
            outputs:
              - Name: Datetime
                Selector: $.Payload.datetime
                Type: String
            description: Gets the current date and time and returns it as output 'Datetime'
          - name: TagInstanceTimestamp
            action: 'aws:createTags'
            inputs:
              ResourceType: EC2
              ResourceIds:
                - '{{InstanceId}}'
              Tags:
                - Key: InstancePatchingLastBeginTime
                  Value: '{{GetDatetime.Datetime}}'
            description: Creates or overwrites the tag 'InstancePatchingLastBeginTime' on the instance with the current Datetime. This can be used to check the last patching start time and as part of logic to find instances that should have been stopped after patching but are still running.            
          - name: TagInstanceState
            action: 'aws:createTags'
            inputs:
              ResourceType: EC2
              ResourceIds:
                - '{{InstanceId}}'
              Tags:
                - Key: InstancePatchingBeginState
                  Value: '{{GetInstanceState.State}}'
            description: Creates the tag InstancePatchingBeginState on the instance with its current state (running or stopped). This can be used to check the instance state as part of logic to find instances that should have been stopped after patching but are still running.
          - name: GetInstanceProfile
            action: 'aws:executeAwsApi'
            outputs:
              - Name: Arn
                Selector: '$.Reservations[0].Instances[0].IamInstanceProfile.Arn'
                Type: String
            inputs:
              Service: ec2
              Api: DescribeInstances
              InstanceIds:
                - '{{InstanceId}}'
            description: Gets the current instance profile Arn.
          - name: choiceAttachProfilePolicies
            action: 'aws:branch'
            inputs: 
              Choices:
                - And:
                    - Variable: '{{GetInstanceProfile.Arn}}'
                      Contains: 'GetInstanceProfile.Arn'
                    - Not:
                        Variable: '{{AttachInstanceProfileArn}}'
                        StringEquals: ''
                  NextStep: AssociateInstanceProfile
              Default: choiceStartInstance
          - name: AssociateInstanceProfile
            action: 'aws:executeAwsApi'
            inputs:
              Service: ec2
              Api: AssociateIamInstanceProfile
              IamInstanceProfile: 
                Arn: '{{AttachInstanceProfileArn}}'
              InstanceId: '{{InstanceId}}'
            outputs:
              - Name: AssociationId
                Selector: $.IamInstanceProfileAssociation.AssociationId              
            isCritical: false
            onFailure: 'step:choiceStartInstance'
            nextStep: choiceStartInstance
          - name: choiceStartInstance
            action: 'aws:branch'
            inputs:
              Choices:
                - Variable: '{{StartInstance}}'
                  EqualsIgnoreCase: 'true'
                  NextStep: StartInstance
              Default: choicePatchInstanceLogToS3
            description: 'When StartInstance is set to true, go to the StartInstance step. Otherwise, go to choicePatchInstanceLogToS3.'       
          - name: StartInstance
            action: 'aws:changeInstanceState'
            inputs:
              InstanceIds:
                - '{{InstanceId}}'
              DesiredState: running
            description: Start the instance if it is not running
            onFailure: 'step:choiceStopInstance'
            onCancel: 'step:choiceStopInstance'
            isCritical: true               
          - name: waitForInstanceOnline
            action: 'aws:waitForAwsResourceProperty'
            inputs:
              Service: ssm
              Api: DescribeInstanceInformation
              InstanceInformationFilterList: 
                - key: InstanceIds
                  valueSet: 
                    - '{{InstanceId}}'
              PropertySelector: "$.InstanceInformationList[0].PingStatus"
              DesiredValues:
                - Online
            timeoutSeconds: !Ref InstanceOnlineTimeoutSeconds
            onFailure: 'step:choiceStopInstance'
            onCancel: 'step:choiceStopInstance'
            isCritical: true
            description: Verify the instance is online and managed by SSM prior to patching. 
          - name: choicePatchInstanceLogToS3
            action: 'aws:branch'
            inputs:
              Choices:
                - Or:
                    - Variable: '{{PatchingOutputS3BucketName}}'
                      StringEquals: ''
                    - Variable: '{{PatchingOutputS3KeyPrefix}}'
                      StringEquals: ''
                  NextStep: PatchInstance
              Default: PatchInstanceLogToS3
            description: 'If PatchingOutputS3BucketName and PatchingOutputS3KeyPrefix are set, go to step that starts patching with execution logs sent to an S3 bucket. Otherwise, go to step that starts patching without sending execution logs to S3.'
          - name: PatchInstanceLogToS3
            action: 'aws:runCommand'
            inputs:
              DocumentName: AWS-RunPatchBaseline
              InstanceIds:
                - '{{InstanceId}}'
              Parameters:
                RebootOption: '{{PatchingRebootOption}}'
                Operation: '{{PatchingOperation}}'
                InstallOverrideList: '{{PatchingInstallOverrideList}}'
              OutputS3BucketName: '{{PatchingOutputS3BucketName}}'
              OutputS3KeyPrefix: '{{PatchingOutputS3KeyPrefix}}'
              TimeoutSeconds: '{{PatchingTimeoutSeconds}}'
            maxAttempts: !Ref PatchingAttempts
            nextStep: choiceGatherInventory
            onFailure: Continue
            isCritical: true
            onCancel: 'step:choiceStopInstance'
            description: Execute AWS-RunPatchBasline and send execution logs to S3.
          - name: PatchInstance
            action: 'aws:runCommand'
            inputs:
              DocumentName: AWS-RunPatchBaseline
              InstanceIds:
                - '{{InstanceId}}'
              Parameters:
                RebootOption: '{{PatchingRebootOption}}'
                Operation: '{{PatchingOperation}}'
                InstallOverrideList: '{{PatchingInstallOverrideList}}'
              TimeoutSeconds: '{{PatchingTimeoutSeconds}}'
            maxAttempts: !Ref PatchingAttempts
            onFailure: Continue
            isCritical: true
            onCancel: 'step:choiceStopInstance'
            description: Execution AWS-RunPatchBaseline
          - name: choiceGatherInventory
            action: 'aws:branch'
            inputs:
              Choices:
                - Variable: '{{GatherInventory}}'
                  EqualsIgnoreCase: 'true'
                  NextStep: choiceGatherInventoryLogToS3
              Default: choiceStopInstance
            description: 'If GatherInventory is true, move to choiceGatherInventoryLogToS3, otherwise go choiceStopInstance.'
            onFailure: Continue
            onCancel: 'step:choiceStopInstance'
          - name: choiceGatherInventoryLogToS3
            action: 'aws:branch'
            inputs:
              Choices:
                - Or:
                    - Variable: '{{InventoryOutputS3BucketName}}'
                      StringEquals: ''
                    - Variable: '{{InventoryOutputS3KeyPrefix}}'
                      StringEquals: ''
                  NextStep: CreateAssociationGatherInventory
              Default: CreateAssociationGatherInventoryLogToS3
            onFailure: 'step:choiceStopInstance'
            onCancel: 'step:choiceStopInstance'
          - name: CreateAssociationGatherInventoryLogToS3
            action: 'aws:executeAwsApi'
            inputs:
              Service: ssm
              Api: CreateAssociation
              Name: AWS-GatherSoftwareInventory
              Parameters:
                applications:
                  - Enabled
                awsComponents:
                  - Enabled
                files:
                  - ''
                networkConfig:
                  - Enabled
                windowsUpdates:
                  - Enabled
                instanceDetailedInformation:
                  - Enabled
                services:
                  - Enabled
                windowsRegistry:
                  - ''
                windowsRoles:
                  - Enabled
                customInventory:
                  - Enabled
                billingInfo:
                  - Enabled
              OutputLocation:
                S3Location:
                  OutputS3BucketName: '{{InventoryOutputS3BucketName}}'
                  OutputS3KeyPrefix: '{{InventoryOutputS3KeyPrefix}}'
              Targets:
                - Key: InstanceIds
                  Values:
                    - '{{InstanceId}}'
              AssociationName: 'Patching-AWS-GatherSoftwareInventory-{{InstanceId}}'
            outputs:
              - Name: AssociationId
                Selector: $.AssociationDescription.AssociationId
                Type: String
            description: Create an association for gathering inventory
            nextStep: GetAssociationId
            onFailure: 'step:choiceStopInstance'
            onCancel: 'step:choiceStopInstance'
          - name: CreateAssociationGatherInventory
            action: 'aws:executeAwsApi'
            inputs:
              Service: ssm
              Api: CreateAssociation
              Parameters:
                applications:
                  - Enabled
                awsComponents:
                  - Enabled
                files:
                  - ''
                networkConfig:
                  - Enabled
                windowsUpdates:
                  - Enabled
                instanceDetailedInformation:
                  - Enabled
                services:
                  - Enabled
                windowsRegistry:
                  - ''
                windowsRoles:
                  - Enabled
                customInventory:
                  - Enabled
                billingInfo:
                  - Enabled
              Name: AWS-GatherSoftwareInventory
              Targets:
                - Key: InstanceIds
                  Values:
                    - '{{InstanceId}}'
              AssociationName: 'Patching-AWS-GatherSoftwareInventory-{{InstanceId}}'
            outputs:
              - Name: AssociationId
                Selector: $.AssociationDescription.AssociationId
                Type: String
            onFailure: 'step:choiceStopInstance'
            onCancel: 'step:choiceStopInstance'
          - name: GetAssociationId
            action: 'aws:executeScript'
            inputs:
              Runtime: python3.7
              Handler: script_handler
              Script: |-
                def script_handler(events, context):
                  print(events.get('CreateAssociation-GatherInventory', ''))
                  print(events.get('CreateAssociation-GatherInventoryLogToS3', ''))
                  if not ('AssociationId}}' in events.get('CreateAssociation-GatherInventory', '') or events.get('CreateAssociation-GatherInventory', '') == ''):
                    return {'AssociationId': events['CreateAssociation-GatherInventory']}
                  else:
                    return  {'AssociationId': events['CreateAssociation-GatherInventoryLogToS3']}
              InputPayload:
                CreateAssociation-GatherInventory: '{{CreateAssociationGatherInventory.AssociationId}}'
                CreateAssociation-GatherInventoryLogToS3: '{{CreateAssociationGatherInventoryLogToS3.AssociationId}}'
            outputs:
              - Name: AssociationId
                Selector: $.Payload.AssociationId
                Type: String
            description: Gets the AssociationId from the previous CreateAssociation call for the following steps.
            onFailure: Continue
            onCancel: 'step:DeleteAssociation'
          - name: StartAssociationsOnce
            action: 'aws:executeAwsApi'
            inputs:
              Api: StartAssociationsOnce
              Service: ssm
              AssociationIds:
                - '{{GetAssociationId.AssociationId}}'
            onFailure: 'step:DeleteAssociation'
            onCancel: 'step:DeleteAssociation'
          - name: waitDescribeAssociationExecutions
            action: 'aws:waitForAwsResourceProperty'
            inputs:
              PropertySelector: '$.AssociationExecutions[0].Status'
              DesiredValues:
                - Success
                - Failed
              AssociationId: '{{GetAssociationId.AssociationId}}'
              Service: ssm
              Api: DescribeAssociationExecutions
            description: Waits for DescribeAssociationStatus to return "Success" or "Failed" to indicate the Association has finished.
            timeoutSeconds: 600
            onFailure: Continue
            isCritical: false
            onCancel: 'step:DeleteAssociation'
          - name: assertDescribeAssociationExecutionsSuccess
            action: 'aws:assertAwsResourceProperty'
            inputs:
              Service: ssm
              Api: DescribeAssociationExecutions
              PropertySelector: '$.AssociationExecutions[0].Status'
              DesiredValues:
                - Success
              AssociationId: '{{GetAssociationId.AssociationId}}'
            description: Asserts that the association completed successfully
            timeoutSeconds: 30
            onCancel: 'step:DeleteAssociation'
            onFailure: Continue
          - name: DeleteAssociation
            action: 'aws:executeAwsApi'
            inputs:
              Service: ssm
              Api: DeleteAssociation
              AssociationId: '{{GetAssociationId.AssociationId}}'
            onFailure: Continue
            onCancel: 'step:choiceStopInstance'
          - name: choiceStopInstance
            action: 'aws:branch'
            inputs:
              Choices:
                - Variable: '{{GetInstanceState.State}}'
                  EqualsIgnoreCase: stopped
                  NextStep: StopInstance
              Default: UntagInstanceState
            description: 'If the instance was previously stopped, go to StopInstance step. Otherwise, skip StopInstance step and go to UntagInstanceState.'
          - name: StopInstance
            action: 'aws:changeInstanceState' 
            inputs:
              InstanceIds:
                - '{{InstanceId}}'
              DesiredState: stopped
            timeoutSeconds: 300
            onFailure: Continue
            onCancel: 'step:ForceStopInstance'
            description: Stop the instance gracefully. This should only run if the instance was previously in a stopped state. Timeout is set to 300 seconds.
          - name: ForceStopInstance
            action: 'aws:changeInstanceState'
            inputs:
              InstanceIds:
                - '{{InstanceId}}'
              DesiredState: stopped
              Force: true
            onFailure: Continue
            isCritical: true
            onCancel: 'step:choiceDisassociateInstanceProfile'
            description: Forcefully stop the instance if it is not already stopped. This should only run if the instance was previously in a stopped state. It will only affect an instance that could not be gracefully stopped in 5 minutes.
          - name: choiceDisassociateInstanceProfile
            action: 'aws:branch'
            inputs:
              Choices:
                - Not:
                    Variable: '{{AssociateInstanceProfile.AssociationId}}'
                    Contains: 'AssociateInstanceProfile.AssociationId'
                  NextStep: DisassociateInstanceProfile
              Default: UntagInstanceState
            description: 'Determine if temporary instance profile was set and needs to be disassociated.'            
          - name: DisassociateInstanceProfile
            action: 'aws:executeAwsApi'
            inputs:
              Service: ec2
              Api: DisassociateIamInstanceProfile
              AssociationId: '{{AssociateInstanceProfile.AssociationId}}'
            outputs:
              - Name: State
                Selector: $.IamInstanceProfileAssociation.State
            onFailure: Continue
            isCritical: true
            description: Disassociates the temporary instance profile from the instance.   
          - name: UntagInstanceState
            action: 'aws:executeAwsApi'
            inputs:
              Service: ec2
              Api: DeleteTags
              Resources:
                - '{{InstanceId}}'
              Tags:
                - Key: InstancePatchingBeginState
            onFailure: Continue
            isCritical: true
            description: Removes the InstancePatchingBeginState tag from the instance. This indicates the instance is no longer being patched. This can be used to check the instance state as part of logic to find instances that should have been stopped after patching but are still running.

          - name: UntagInstancePatchingLastExecutionId
            action: 'aws:executeAwsApi'
            inputs:
              Service: ec2
              Api: DeleteTags
              Resources:
                - '{{InstanceId}}'
              Tags:
                - Key: InstancePatchingLastExecutionId
            onFailure: Continue   
            isCritical: true

  #-------------------------------------------------
  # The automation execution role that is used to execute the patching automation. 
  #-------------------------------------------------
  PatchingRole:
    Type: AWS::IAM::Role
    Properties:
      Path: '/'
      RoleName: !Sub "patching-role-${AWS::Region}"
      AssumeRolePolicyDocument: 
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service: ssm.amazonaws.com
            Action: 'sts:AssumeRole'                
      Policies:
        - PolicyName: "PatchingAutomationRolePolicy"
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: "Allow"
                Action: 
                  - ec2:CreateTags 
                  - ec2:DeleteTags
                  - ec2:DescribeTags
                  - ec2:DescribeInstances
                  - ec2:DescribeInstanceStatus
                  - ec2:StopInstances
                  - ec2:StartInstances
                  - ec2:AssociateIamInstanceProfile
                  - ec2:DisassociateIamInstanceProfile
                  - iam:ListInstanceProfiles
                  - ssm:DescribeInstanceInformation
                  - ssm:CreateAssociation
                  - ssm:StartAssociationsOnce
                  - ssm:DeleteAssociation
                  - ssm:DescribeAssociationExecutions
                  - ssm:DescribeAutomationExecutions
                  - ssm:SendCommand
                  - ssm:ListCommands
                  - ssm:ListCommandInvocations
                Resource: "*"
              - Effect: "Allow"
                Action: 
                  - 'iam:AttachRolePolicy'                  
                Resource: "*"
                Condition:
                  ForAllValues:StringEqualsIgnoreCase:
                    iam:PolicyARN:
                      - 'arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore'
                      - 'arn:aws:iam::aws:policy/AmazonSSMPatchAssociation'
                      - !Sub ${PatchingManagedPolicy}                
              - Effect: "Allow"
                Action:
                  - iam:PassRole
                Resource: 
                  - !Sub 'arn:aws:iam::${AWS::AccountId}:role/patching-role-${AWS::Region}'
                  - !Sub ${PatchingInstanceProfileRole.Arn}
              
  
  PatchingAssociation:
    Type: 'AWS::SSM::Association'
    Properties:
      Name: !Ref PatchingAutomation
      ScheduleExpression: !Sub '${PatchSchedule}'
      AutomationTargetParameterName: InstanceId      
      ApplyOnlyAtCronInterval: True
      AssociationName: !Sub Patching-${AWS::AccountId}-${AWS::Region}
      Parameters:
        AutomationAssumeRole: 
          - !GetAtt PatchingRole.Arn      
        PatchingOperation: 
          - !Sub ${PatchingOperation}
        PatchingRebootOption: 
          - !Sub ${PatchingRebootOption}
        PatchingInstallOverrideList: 
          - !Sub ${PatchingInstallOverrideList}
        PatchingOutputS3BucketName: 
          - !Sub ${ExecutionLogsS3Bucket}
        PatchingOutputS3KeyPrefix: 
          - !Sub ${PatchingExecutionLogsS3BucketPrefix}/accountid={{global:ACCOUNT_ID}}/region={{global:REGION}}/executionid={{automation:EXECUTION_ID}}
        InventoryOutputS3BucketName: 
          - !Sub ${ExecutionLogsS3Bucket}
        InventoryOutputS3KeyPrefix: 
          - !Sub ${InventoryExecutionLogsS3BucketPrefix}/accountid={{global:ACCOUNT_ID}}/region={{global:REGION}}/executionid={{automation:EXECUTION_ID}}        
        PatchingTimeoutSeconds: 
          - !Sub ${PatchingTimeoutSeconds}
        GatherInventory: 
          - !Sub ${GatherInventory}
        StartInstance: 
          - !Sub ${StartInstances}
        AttachInstanceProfileArn:
          - !If 
              - AutoAttachInstanceProfile
              - !Sub ${PatchingInstanceProfile.Arn}
              - !Ref AWS::NoValue
      Targets:
        - Values:
            - '*'
          Key: InstanceIds


  #-------------------------------------------------
  # Instance profile role that can be temporarily attached to instances to run SSM patching and inventory commands. 
  #-------------------------------------------------
  PatchingInstanceProfileRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "patching-instance-role-${AWS::Region}"
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          Sid: AssumeRole
          Effect: Allow
          Principal:
            Service:
              - ec2.amazonaws.com
          Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore
        - arn:aws:iam::aws:policy/CloudWatchAgentServerPolicy

  #-------------------------------------------------
  # IAM policy attached to the patching role to grant permission to write to execution logs bucket
  #-------------------------------------------------
  PatchingManagedPolicy:
    Type: AWS::IAM::ManagedPolicy
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: F5
    Properties:
      Description: Default Permissions for EC2 instances
      ManagedPolicyName: !Sub "patching-instance-perms-${AWS::Region}"
      Roles:
        - !Ref PatchingInstanceProfileRole
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Sid: S3GetExecutionBucket
            Effect: Allow
            Action:
              - s3:List*
              - s3:GetObject
              - s3:GetEncryptionConfiguration
            Resource:
              - !Sub "arn:aws:s3:::${ExecutionLogsS3Bucket}/*"
              - !Sub "arn:aws:s3:::${ExecutionLogsS3Bucket}"
          - Sid: S3putlogs
            Effect: Allow
            Action:
              - s3:PutObject
              - s3:PutObjectAcl
            Resource:
              - !Sub "arn:aws:s3:::${ExecutionLogsS3Bucket}/${InventoryExecutionLogsS3BucketPrefix}/*"
              - !Sub "arn:aws:s3:::${ExecutionLogsS3Bucket}/${PatchingExecutionLogsS3BucketPrefix}/*"

  #-------------------------------------------------
  # Instance profile that can be temporarily attached to instances to run SSM patching and inventory commands. 
  #-------------------------------------------------
  PatchingInstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      InstanceProfileName: !Ref PatchingInstanceProfileRole
      Roles:
        - !Ref PatchingInstanceProfileRole                

Outputs:
  StackArn:
    Value:
      Ref: 'AWS::StackId'